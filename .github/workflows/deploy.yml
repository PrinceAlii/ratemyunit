name: Deploy

on:
  push:
    branches: ['main']
  pull_request:
    branches: ['main']
  workflow_dispatch:

permissions:
  id-token: write
  contents: read

concurrency:
  group: deploy-production
  cancel-in-progress: false  # Never cancel mid-flight deployments

env:
  AWS_REGION: ap-southeast-2
  TF_VERSION: '1.14.4'

jobs:
  changes:
    name: Check for changes
    runs-on: ubuntu-latest
    outputs:
      infra: ${{ steps.filter.outputs.infra }}
      backend: ${{ steps.filter.outputs.backend }}
      frontend: ${{ steps.filter.outputs.frontend }}
    steps:
      - uses: actions/checkout@v4
      - uses: dorny/paths-filter@v3
        id: filter
        with:
          filters: |
            infra:
              - 'terraform/**'
              - '.github/workflows/deploy.yml'
            backend:
              - 'apps/api/**'
              - 'packages/**'
              - 'package.json'
              - 'package-lock.json'
            frontend:
              - 'apps/web/**'
              - 'packages/**'
              - 'package.json'
              - 'package-lock.json'

  infra-plan:
    name: Terraform Plan
    needs: changes
    if: needs.changes.outputs.infra == 'true' || github.event_name == 'pull_request'
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_DEPLOY_ROLE }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TF_VERSION }}

      - name: Terraform Init Cache
        uses: actions/cache@v4
        with:
          path: terraform/.terraform
          key: ${{ runner.os }}-terraform-${{ hashFiles('terraform/*.tf', 'terraform/.terraform.lock.hcl') }}
          restore-keys: |
            ${{ runner.os }}-terraform-

      - name: Terraform Init
        run: terraform init
        working-directory: terraform

      - name: Terraform Plan
        id: plan
        run: terraform plan -out=main.tfplan
        working-directory: terraform

      - name: Upload Plan Artifact
        uses: actions/upload-artifact@v4
        with:
          name: terraform-plan
          path: terraform/main.tfplan
          retention-days: 7

  infra-apply:
    name: Terraform Apply
    needs: [changes, infra-plan]
    if: (needs.changes.outputs.infra == 'true' && github.event_name == 'push')
    runs-on: ubuntu-latest
    environment: production
    outputs:
      ecr_repository: ${{ steps.tf-out.outputs.ecr_repository_url }}
      api_public_ip: ${{ steps.tf-out.outputs.api_public_ip }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Download Plan Artifact
        uses: actions/download-artifact@v4
        with:
          name: terraform-plan
          path: terraform

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_DEPLOY_ROLE }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TF_VERSION }}

      - name: Terraform Init Cache
        uses: actions/cache@v4
        with:
          path: terraform/.terraform
          key: ${{ runner.os }}-terraform-${{ hashFiles('terraform/*.tf', 'terraform/.terraform.lock.hcl') }}

      - name: Terraform Init
        run: terraform init
        working-directory: terraform

      - name: Terraform Apply
        run: terraform apply -auto-approve main.tfplan
        working-directory: terraform

      - name: Get Terraform Outputs
        id: tf-out
        working-directory: terraform
        run: |
          echo "ecr_repository_url=$(terraform output -raw ecr_repository_url)" >> $GITHUB_OUTPUT
          echo "api_public_ip=$(terraform output -raw api_public_ip)" >> $GITHUB_OUTPUT

  deploy-backend:
    name: Deploy API + Frontend
    needs: [changes, infra-apply]
    if: |
      (needs.changes.outputs.backend == 'true' ||
       needs.changes.outputs.frontend == 'true' ||
       needs.changes.outputs.infra == 'true') &&
      github.event_name == 'push' &&
      (always() && (needs.infra-apply.result == 'success' || needs.infra-apply.result == 'skipped'))
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_DEPLOY_ROLE }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Build and Push Docker Image
        uses: docker/build-push-action@v5
        with:
          context: .
          file: apps/api/Dockerfile
          push: true
          tags: |
            ${{ steps.login-ecr.outputs.registry }}/ratemyunit-api:latest
            ${{ steps.login-ecr.outputs.registry }}/ratemyunit-api:${{ github.sha }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

      - name: Tag Current Version for Rollback
        id: backup
        run: |
          INSTANCE_ID=$(aws ec2 describe-instances \
            --filters \
              "Name=tag:Name,Values=ratemyunit-api" \
              "Name=instance-state-name,Values=running" \
            --query 'Reservations[0].Instances[0].InstanceId' \
            --output text)

          if [[ -n "$INSTANCE_ID" && "$INSTANCE_ID" != "None" ]]; then
            # Get current running image
            CURRENT_IMAGE=$(aws ssm send-command \
              --document-name "AWS-RunShellScript" \
              --targets "Key=tag:Name,Values=ratemyunit-api" \
              --parameters 'commands=["docker inspect ratemyunit-api --format=\"{{.Image}}\" 2>/dev/null || echo none"]' \
              --query 'Command.CommandId' \
              --output text)

            # Wait and get result
            sleep 5
            BACKUP_IMAGE=$(aws ssm get-command-invocation \
              --command-id "$CURRENT_IMAGE" \
              --instance-id "$INSTANCE_ID" \
              --query 'StandardOutputContent' \
              --output text | tr -d '[:space:]')

            if [[ -n "$BACKUP_IMAGE" && "$BACKUP_IMAGE" != "none" ]]; then
              echo "backup_image=$BACKUP_IMAGE" >> $GITHUB_OUTPUT
              echo "‚úì Tagged backup image: $BACKUP_IMAGE"
            else
              echo "‚ö† No existing container found (likely first deployment)"
              echo "backup_image=none" >> $GITHUB_OUTPUT
            fi
          else
            echo "backup_image=none" >> $GITHUB_OUTPUT
          fi

      # Pre-deployment migrations: Run migrations on the OLD container before deploying
      # This ensures the database is ready for the new code
      # NOTE: Migration scripts use .mjs (ES modules) from scripts/ directory
      # Seed script uses .js (transpiled) from dist/ directory
      # This is intentional - migrations are run directly, seeding is built first
      - name: Run Database Migrations
        run: |
          # Resolve instance ID
          INSTANCE_ID=$(aws ec2 describe-instances \
            --filters \
              "Name=tag:Name,Values=ratemyunit-api" \
              "Name=instance-state-name,Values=running" \
            --query 'Reservations[0].Instances[0].InstanceId' \
            --output text)

          if [[ -z "$INSTANCE_ID" || "$INSTANCE_ID" == "None" ]]; then
            echo "‚ö† No running instance found, skipping pre-deployment migrations"
            exit 0
          fi

          echo "Running migrations on instance: $INSTANCE_ID"

          COMMAND_ID=$(aws ssm send-command \
            --document-name "AWS-RunShellScript" \
            --targets "Key=tag:Name,Values=ratemyunit-api" \
            --parameters 'commands=["export DATABASE_URL=$(aws ssm get-parameter --name /ratemyunit/production/database/url --with-decryption --query Parameter.Value --output text --region ${{ env.AWS_REGION }})", "docker exec -e DATABASE_URL=\"$DATABASE_URL\" ratemyunit-api node /app/packages/db/scripts/apply-migrations.mjs 2>&1 || echo \"Container not running yet, will migrate after deployment\""]' \
            --comment "Running database migrations" \
            --query 'Command.CommandId' \
            --output text)

          echo "Migration command ID: $COMMAND_ID"

          # Wait for command to complete (timeout after 30 seconds)
          for i in {1..30}; do
            STATUS=$(aws ssm get-command-invocation \
              --command-id "$COMMAND_ID" \
              --instance-id "$INSTANCE_ID" \
              --query 'Status' \
              --output text 2>/dev/null || echo "Pending")

            if [[ "$STATUS" == "Success" || "$STATUS" == "Failed" ]]; then
              echo "Migration status: $STATUS"
              aws ssm get-command-invocation \
                --command-id "$COMMAND_ID" \
                --instance-id "$INSTANCE_ID" \
                --query 'StandardOutputContent' \
                --output text
              break
            fi

            sleep 1
          done

          # Check if we actually got a result or timed out
          if [[ "$STATUS" != "Success" && "$STATUS" != "Failed" ]]; then
            echo "‚úó Pre-deployment migrations timed out"
            exit 1
          fi

      # Deploy new container: Stop old, start new
      # Uses SSM to execute commands on EC2 without SSH access
      - name: Deploy to EC2 via SSM
        run: |
          # Resolve instance ID first
          INSTANCE_ID=$(aws ec2 describe-instances \
            --filters \
              "Name=tag:Name,Values=ratemyunit-api" \
              "Name=instance-state-name,Values=running" \
            --query 'Reservations[0].Instances[0].InstanceId' \
            --output text)

          if [[ -z "$INSTANCE_ID" || "$INSTANCE_ID" == "None" ]]; then
            echo "‚úó Cannot resolve EC2 instance for deployment" && exit 1
          fi

          echo "Deploying to instance: $INSTANCE_ID"

          COMMAND_ID=$(aws ssm send-command \
            --document-name "AWS-RunShellScript" \
            --targets "Key=tag:Name,Values=ratemyunit-api" \
            --parameters 'commands=["docker rm -f ratemyunit-api || true", "export DATABASE_URL=$(aws ssm get-parameter --name /ratemyunit/production/database/url --with-decryption --query Parameter.Value --output text --region ${{ env.AWS_REGION }})", "export REDIS_URL=$(aws ssm get-parameter --name /ratemyunit/production/redis/url --with-decryption --query Parameter.Value --output text --region ${{ env.AWS_REGION }})", "export JWT_SECRET=$(aws ssm get-parameter --name /ratemyunit/production/jwt/secret --with-decryption --query Parameter.Value --output text --region ${{ env.AWS_REGION }})", "export FRONTEND_URL=$(aws ssm get-parameter --name /ratemyunit/production/frontend/url --query Parameter.Value --output text --region ${{ env.AWS_REGION }})", "aws ecr get-login-password --region ${{ env.AWS_REGION }} | docker login --username AWS --password-stdin ${{ steps.login-ecr.outputs.registry }}", "docker pull ${{ steps.login-ecr.outputs.registry }}/ratemyunit-api:${{ github.sha }}", "docker run -d --name ratemyunit-api --network ratemyunit-net --restart unless-stopped -p 80:3000 -e NODE_ENV=production -e PORT=3000 -e DATABASE_URL=$DATABASE_URL -e REDIS_URL=$REDIS_URL -e JWT_SECRET=$JWT_SECRET -e FRONTEND_URL=$FRONTEND_URL ${{ steps.login-ecr.outputs.registry }}/ratemyunit-api:${{ github.sha }}"]' \
            --comment "Deploying backend" \
            --query 'Command.CommandId' \
            --output text)

          echo "Deployment command ID: $COMMAND_ID"

          # Wait for deployment to complete (timeout after 5 minutes)
          for i in {1..60}; do
            STATUS=$(aws ssm get-command-invocation \
              --command-id "$COMMAND_ID" \
              --instance-id "$INSTANCE_ID" \
              --query 'Status' \
              --output text 2>/dev/null || echo "Pending")

            if [[ "$STATUS" == "Success" ]]; then
              echo "‚úì Deployment completed successfully"
              break
            elif [[ "$STATUS" == "Failed" ]]; then
              echo "‚úó Deployment failed"
              aws ssm get-command-invocation \
                --command-id "$COMMAND_ID" \
                --instance-id "$INSTANCE_ID" \
                --query 'StandardOutputContent' \
                --output text
              exit 1
            fi

            echo "Waiting for deployment... ($i/60)"
            sleep 5
          done

          if [[ "$STATUS" != "Success" ]]; then
            echo "‚úó Deployment timed out after 5 minutes"
            exit 1
          fi

      - name: Wait for Container to Start
        run: |
          echo "Waiting for container to be ready..."
          sleep 10
          INSTANCE_ID="None"
          attempt=0
          until [[ -n "$INSTANCE_ID" && "$INSTANCE_ID" != "None" ]]; do
            DESCRIBE_RESULT=$(aws ec2 describe-instances \
              --filters \
                "Name=tag:Name,Values=ratemyunit-api" \
              --query 'Reservations[0].Instances[0]' \
              --output json)
            INSTANCE_ID=$(echo "$DESCRIBE_RESULT" | jq -r '.InstanceId // empty')
            INSTANCE_STATE=$(echo "$DESCRIBE_RESULT" | jq -r '.State.Name // empty')
            attempt=$((attempt + 1))
            if [[ $attempt -ge 60 ]]; then
              echo "‚úó Unable to resolve EC2 instance ID"
              echo "EC2 describe output:"
              echo "$DESCRIBE_RESULT"
              exit 1
            fi
            sleep 5
          done

          if [[ "$INSTANCE_STATE" != "running" ]]; then
            if [[ "$INSTANCE_STATE" == "stopped" ]]; then
              echo "Instance is stopped. Starting..."
              aws ec2 start-instances --instance-ids "$INSTANCE_ID"
              aws ec2 wait instance-running --instance-ids "$INSTANCE_ID"
              echo "‚úì Instance is now running"
            elif [[ "$INSTANCE_STATE" == "stopping" || "$INSTANCE_STATE" == "pending" ]]; then
              echo "Instance is in transitional state: $INSTANCE_STATE. Waiting..."
              aws ec2 wait instance-running --instance-ids "$INSTANCE_ID"
              echo "‚úì Instance is now running"
            else
              echo "‚úó Instance is in unexpected state: $INSTANCE_STATE"
              exit 1
            fi
          fi

          COMMAND_ID=$(aws ssm send-command \
            --document-name "AWS-RunShellScript" \
            --targets "Key=tag:Name,Values=ratemyunit-api" \
            --parameters 'commands=["docker ps --filter name=ratemyunit-api --format \"{{.Status}}\""]' \
            --comment "Verify container started (${INSTANCE_ID})" \
            --query 'Command.CommandId' \
            --output text)

          attempt=0
          until aws ssm get-command-invocation \
            --command-id "$COMMAND_ID" \
            --instance-id "$INSTANCE_ID" \
            --query 'Status' \
            --output text >/tmp/ssm-status 2>/tmp/ssm-error; do
            attempt=$((attempt + 1))
            if [[ $attempt -ge 60 ]]; then
              echo "‚úó Timed out waiting for SSM command invocation" >&2
              echo "SSM error log:"
              cat /tmp/ssm-error
              exit 1
            fi
            sleep 1
          done

          STATUS=$(cat /tmp/ssm-status)
          echo "Command invocation status: $STATUS"

          aws ssm get-command-invocation \
            --command-id "$COMMAND_ID" \
            --instance-id "$INSTANCE_ID" \
            --query 'StandardOutputContent' \
            --output text

      # Post-deployment migrations: Run any new migrations in the NEW container
      # This handles migrations that can only run after the new code is deployed
      - name: Run Post-Deployment Migrations
        run: |
          echo "Running database migrations in the new container..."
          INSTANCE_ID=$(aws ec2 describe-instances \
            --filters \
              "Name=tag:Name,Values=ratemyunit-api" \
              "Name=instance-state-name,Values=running" \
            --query 'Reservations[0].Instances[0].InstanceId' \
            --output text)
          if [[ -z "$INSTANCE_ID" || "$INSTANCE_ID" == "None" ]]; then
            echo "‚úó Cannot resolve EC2 instance for migrations" && exit 1
          fi

          echo "Running migrations on instance: $INSTANCE_ID"

          COMMAND_ID=$(aws ssm send-command \
            --document-name "AWS-RunShellScript" \
            --targets "Key=tag:Name,Values=ratemyunit-api" \
            --parameters 'commands=["export DATABASE_URL=$(aws ssm get-parameter --name /ratemyunit/production/database/url --with-decryption --query Parameter.Value --output text --region ${{ env.AWS_REGION }})", "aws ecr get-login-password --region ${{ env.AWS_REGION }} | docker login --username AWS --password-stdin ${{ steps.login-ecr.outputs.registry }}", "docker run --rm --network ratemyunit-net -e DATABASE_URL=\"$DATABASE_URL\" ${{ steps.login-ecr.outputs.registry }}/ratemyunit-api:${{ github.sha }} node /app/packages/db/scripts/apply-migrations.mjs 2>&1"]' \
            --comment "Post-deployment migrations" \
            --query 'Command.CommandId' \
            --output text)

          echo "Migration command ID: $COMMAND_ID"

          # Wait for migrations to complete
          for i in {1..60}; do
            STATUS=$(aws ssm get-command-invocation \
              --command-id "$COMMAND_ID" \
              --instance-id "$INSTANCE_ID" \
              --query 'Status' \
              --output text 2>/dev/null || echo "Pending")

            if [[ "$STATUS" == "Success" ]]; then
              echo "‚úì Migrations completed successfully"
              aws ssm get-command-invocation \
                --command-id "$COMMAND_ID" \
                --instance-id "$INSTANCE_ID" \
                --query 'StandardOutputContent' \
                --output text
              break
            elif [[ "$STATUS" == "Failed" ]]; then
              echo "‚úó Migrations failed"
              aws ssm get-command-invocation \
                --command-id "$COMMAND_ID" \
                --instance-id "$INSTANCE_ID" \
                --query 'StandardOutputContent' \
                --output text
              exit 1
            fi

            echo "Waiting for migrations... ($i/60)"
            sleep 2
          done

          # Check if we actually got a result or timed out
          if [[ "$STATUS" != "Success" && "$STATUS" != "Failed" ]]; then
            echo "‚úó Post-deployment migrations timed out"
            exit 1
          fi

      # Database seeding: Idempotent operation to ensure reference data exists
      # Safe to run multiple times, only inserts missing data
      - name: Seed Database
        run: |
          echo "Seeding database with initial data (idempotent - safe to run multiple times)..."

          # Resolve instance ID
          INSTANCE_ID=$(aws ec2 describe-instances \
            --filters \
              "Name=tag:Name,Values=ratemyunit-api" \
              "Name=instance-state-name,Values=running" \
            --query 'Reservations[0].Instances[0].InstanceId' \
            --output text)

          if [[ -z "$INSTANCE_ID" || "$INSTANCE_ID" == "None" ]]; then
            echo "‚úó Cannot resolve EC2 instance for seeding" && exit 1
          fi

          echo "Seeding database on instance: $INSTANCE_ID"

          COMMAND_ID=$(aws ssm send-command \
            --document-name "AWS-RunShellScript" \
            --targets "Key=tag:Name,Values=ratemyunit-api" \
            --parameters 'commands=["export DATABASE_URL=$(aws ssm get-parameter --name /ratemyunit/production/database/url --with-decryption --query Parameter.Value --output text --region ${{ env.AWS_REGION }})", "docker exec -e DATABASE_URL=\"$DATABASE_URL\" ratemyunit-api node /app/packages/db/dist/seed.js 2>&1"]' \
            --comment "Database seeding" \
            --query 'Command.CommandId' \
            --output text)

          echo "Seeding command ID: $COMMAND_ID"

          # Wait for seeding to complete
          for i in {1..120}; do
            STATUS=$(aws ssm get-command-invocation \
              --command-id "$COMMAND_ID" \
              --instance-id "$INSTANCE_ID" \
              --query 'Status' \
              --output text 2>/dev/null || echo "Pending")

            if [[ "$STATUS" == "Success" ]]; then
              echo "‚úì Database seeded successfully"
              aws ssm get-command-invocation \
                --command-id "$COMMAND_ID" \
                --instance-id "$INSTANCE_ID" \
                --query 'StandardOutputContent' \
                --output text
              break
            elif [[ "$STATUS" == "Failed" ]]; then
              echo "‚úó Seeding failed"
              aws ssm get-command-invocation \
                --command-id "$COMMAND_ID" \
                --instance-id "$INSTANCE_ID" \
                --query 'StandardOutputContent' \
                --output text
              exit 1
            fi

            echo "Waiting for seeding... ($i/120)"
            sleep 2
          done

          # Check if we actually got a result or timed out
          if [[ "$STATUS" != "Success" && "$STATUS" != "Failed" ]]; then
            echo "‚úó Database seeding timed out"
            exit 1
          fi

      - name: Health Check
        run: |
          echo "Running health check on deployed application..."

          # Get the public IP from EC2
          API_IP=$(aws ec2 describe-instances \
            --filters \
              "Name=tag:Name,Values=ratemyunit-api" \
              "Name=instance-state-name,Values=running" \
            --query 'Reservations[0].Instances[0].PublicIpAddress' \
            --output text)

          if [[ -z "$API_IP" || "$API_IP" == "None" ]]; then
            echo "‚úó Cannot resolve API public IP"
            exit 1
          fi

          echo "Checking health at: http://$API_IP/health"

          # Wait for app to be ready and check health
          for i in {1..30}; do
            HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" "http://$API_IP/health" 2>/dev/null || echo "000")

            if [[ "$HTTP_CODE" == "200" ]]; then
              echo "‚úì Application is healthy (HTTP $HTTP_CODE)"

              # Get and display health check details
              curl -s "http://$API_IP/health" | jq '.' || true
              exit 0
            fi

            echo "Health check attempt $i/30 (HTTP $HTTP_CODE)..."
            sleep 10
          done

          echo "‚úó Health check failed after 5 minutes"
          exit 1

      - name: Rollback on Failure
        if: failure() && steps.backup.outputs.backup_image != 'none'
        run: |
          echo "üîÑ Rolling back to previous version: ${{ steps.backup.outputs.backup_image }}"

          INSTANCE_ID=$(aws ec2 describe-instances \
            --filters \
              "Name=tag:Name,Values=ratemyunit-api" \
              "Name=instance-state-name,Values=running" \
            --query 'Reservations[0].Instances[0].InstanceId' \
            --output text)

          aws ssm send-command \
            --document-name "AWS-RunShellScript" \
            --targets "Key=tag:Name,Values=ratemyunit-api" \
            --parameters "commands=[\"docker rm -f ratemyunit-api || true\", \"export DATABASE_URL=\$(aws ssm get-parameter --name /ratemyunit/production/database/url --with-decryption --query Parameter.Value --output text --region ${{ env.AWS_REGION }})\", \"export REDIS_URL=\$(aws ssm get-parameter --name /ratemyunit/production/redis/url --with-decryption --query Parameter.Value --output text --region ${{ env.AWS_REGION }})\", \"export JWT_SECRET=\$(aws ssm get-parameter --name /ratemyunit/production/jwt/secret --with-decryption --query Parameter.Value --output text --region ${{ env.AWS_REGION }})\", \"export FRONTEND_URL=\$(aws ssm get-parameter --name /ratemyunit/production/frontend/url --query Parameter.Value --output text --region ${{ env.AWS_REGION }})\", \"docker run -d --name ratemyunit-api --network ratemyunit-net --restart unless-stopped -p 80:3000 -e NODE_ENV=production -e PORT=3000 -e DATABASE_URL=\$DATABASE_URL -e REDIS_URL=\$REDIS_URL -e JWT_SECRET=\$JWT_SECRET -e FRONTEND_URL=\$FRONTEND_URL ${{ steps.backup.outputs.backup_image }}\"]" \
            --comment "Rolling back deployment"

          echo "‚úì Rollback initiated"
          exit 1

      - name: Notify Deployment Status
        if: always()
        run: |
          if [[ "${{ job.status }}" == "success" ]]; then
            EMOJI="‚úÖ"
            STATUS="succeeded"
            COLOR="good"
          else
            EMOJI="‚ùå"
            STATUS="failed"
            COLOR="danger"
          fi

          echo "${EMOJI} Deployment ${STATUS} for commit ${{ github.sha }}"
          echo "Workflow: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}"
